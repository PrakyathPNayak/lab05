## Known issues:

| **Issue**                       | **Type**       | **Line(s)**                       | **Description**                                                                                                                                                                | **Fix Approach**                                                                                                                                                                                  |
| ------------------------------- | -------------- | --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Dangerous default value**     | Bug            | 8                                 | logs=[] is a mutable default argument. This list will be shared and modified across all calls to the function that don't pass their own list.                                  | Change the default to logs=None and initialize if logs is None: logs = [] inside the function.                                                                                                    |
| **Bare except with pass**       | Bug / Security | 19                                | A bare except: (flagged by Pylint & Flake8) catches _all_ exceptions, including SystemExit. Bandit (B110) notes it's combined with pass, which silences errors and hides bugs. | Specify the exact exception to catch, such as except KeyError:, and provide feedback (e.g., print(f"Error: {item} not found.")).                                                                  |
| **Use of eval**                 | Security       | 59                                | eval() (flagged by Pylint & Bandit B307) executes code from a string, which is a major remote code execution (RCE) vulnerability if the string can be user-influenced.         | Remove the eval() call. For this demo code, simply delete the line. If data parsing were needed, use ast.literal_eval.                                                                            |
| **Improper whitespace**         | Convention     | 8, 14, 22, 25, 31, 36, 41, 48, 61 | Flake8 (E302, E305) found that functions are not separated by the standard two blank lines required by PEP 8.                                                                  | Add a second blank line between each function definition.                                                                                                                                         |
| **Non-standard naming**         | Convention     | 8, 14, 22, 25, 31, 36, 41         | Pylint (C0103) flagged that function names use camelCase (e.g., addItem) instead of the standard snake_case (e.g., add_item).                                                  | Rename all functions to conform to snake_case.                                                                                                                                                    |
| **Missing docstrings**          | Convention     | 1, 8, 14, 22, 25, 31, 36, 41, 48  | Pylint (C0114, C0116) reported that the module itself and every function are missing docstrings explaining their purpose.                                                      | Add a module-level docstring at the top of the file and a docstring to each function.                                                                                                             |
| **Unsafe file handling**        | Refactor       | 26, 32                            | Pylint (R1732, W1514) noted files are opened without a with statement (risking resource leaks) and without specifying an encoding.                                             | Use the with open(file, "r", encoding="utf-8") as f: pattern for both loadData and saveData.                                                                                                      |
| **Use of global statement**     | Refactor       | 27                                | Pylint (W0603) flagged the use of global stock_data, which makes code hard to test and reason about.                                                                           | Move everything into a class and make stock_data a class variable, this way, the functions would still be able to access the variable without it being a global and it will be instance specific. |
| **Unused import**               | Refactor       | 2                                 | Pylint (W0611) and Flake8 (F401) both found that the logging module is imported but never used.                                                                                | Remove the import logging line.                                                                                                                                                                   |
| **Old-style string formatting** | Convention     | 12                                | Pylint (C0209) flagged the use of C-style % formatting, recommending a modern f-string.                                                                                        | Change the line to an f-string: logs.append(f"{datetime.now()}: Added {qty} of {item}").                                                                                                          |

## Reflection:
1. **Which issues were the easiest to fix, and which were the hardest? Why?** <br>
	The easiest issues to fix were purely mechanical changes that required no logical thinking. Adding blank lines between functions, removing unused imports, and converting old-style string formatting to f-strings were straightforward find-and-replace operations. Writing docstrings was tedious but simple since I only needed to document existing functionality.
	
	The hardest issue was eliminating the global statement. This wasn't just a syntax fix; it required rethinking the entire program architecture. I had to choose between keeping the procedural style with globals, refactoring to a class-based approach, or passing data as parameters throughout. The mutable default argument was also challenging because understanding why `logs=[]` is dangerous requires knowledge of Python's evaluation model, where defaults are created once at function definition rather than per call. The difference between easy and hard fixes comes down to whether they're syntactic changes versus semantic issues that require understanding language behavior and making architectural decisions.

3. **Did the static analysis tools report any false positives? If so, describe one example.** <br>
	I didn't encounter true false positives in this code, but the global statement warning (W0603) is debatable. For simple scripts or module-level singletons, using a global variable can be perfectly pragmatic and acceptable. The warning assumes globals are always bad, but sometimes they're the right choice for configuration, caches, or application state in small programs. However, I'd call this a "code smell" warning rather than a false positive, the tool is correctly identifying that the code works but isn't ideal for testability and maintainability. A true false positive would be something like Pylint complaining about a variable name that's actually a domain-standard convention, such as `df` for DataFrames in pandas code.

4. **How would you integrate static analysis tools into your actual software development workflow? Consider continuous integration (CI) or local development practices.** <br>
	I would integrate static analysis at three levels for maximum effectiveness. First, in local development using pre-commit hooks with tools like Black, Flake8, and Pylint to catch issues before they're even committed. This provides automatic formatting and prevents style debates. Second, IDE integration through VS Code extensions or PyCharm's built-in inspections gives real-time feedback as you type, catching problems immediately. Third, in the CI/CD pipeline using GitHub Actions or similar to run comprehensive checks on every push and pull request. The key is to start by blocking only critical issues like security vulnerabilities and syntax errors, then gradually expand to style warnings that generate reports but don't block merges. This gradual adoption strategy helps teams adapt without feeling overwhelmed, start with optional local tools, add pre-commit hooks, then slowly tighten CI strictness over several months as the codebase improves.

5. **What tangible improvements did you observe in the code quality, readability, or potential robustness after applying the fixes?** <br>
	The code quality improved dramatically across multiple dimensions. Security went from critical vulnerabilities with `eval()` and bare exception handling to a safe, robust implementation. The mutable default argument bug was a silent corruption issue that would have caused mysterious failures in production, now it's fixed with proper initialization. Resource management improved from potentially leaking file handles to guaranteed cleanup with context managers. The shift from global variables and camelCase naming with no documentation to a class-based design with snake_case and comprehensive docstrings makes the code vastly more maintainable and approachable for new developers.
